<!doctype html><html lang=ru><head><script defer language=javascript type=text/javascript src=/js/bundle.min.80ae934052b8d5ace090ee2a536dd246bb0fed7b634c40cf7c6dee916814b705.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.png><title itemprop=name>Кот Не Работает - А как же строки?</title><meta property="og:title" content="Кот Не Работает - А как же строки?"><meta itemprop=name content="Кот Не Работает - А как же строки?"><meta name=application-name content="Кот Не Работает - А как же строки?"><meta property="og:site_name" content><meta name=description content><meta itemprop=description content><meta property="og:description" content><meta name=twitter:description content><base href=https://rokkerruslan.github.io/posts/bytes-and-strings/><link rel=canonical href=https://rokkerruslan.github.io/posts/bytes-and-strings/ itemprop=url><meta name=url content="https://rokkerruslan.github.io/posts/bytes-and-strings/"><meta property="og:url" content="https://rokkerruslan.github.io/posts/bytes-and-strings/"><meta property="og:updated_time" content="20005-20-12T50:00:23Z"><link rel=sitemap type=application/xml title=Sitemap href=https://rokkerruslan.github.io/sitemap.xml><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=apple-mobile-web-app-title content><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta property="og:type" content="article"><meta property="article:publisher" content><meta property="og:article:published_time" content="20005-20-12T50:00:23Z"><meta property="article:published_time" content="20005-20-12T50:00:23Z"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"А как же строки?","author":{"@type":"Person","name":"https:\/\/github.com\/rokkerruslan"},"datePublished":"2023-05-20","description":"","wordCount":5002,"mainEntityOfPage":"True","dateModified":"2023-05-20","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"","logo":{"@type":"imageObject","url":""}}}</script><link type=text/css rel=stylesheet href=/css/bundle.min.0700c387c5c474eda2626657513c49452ac68cd9fb67aa6e04ab79f7c3d58469.css><style>body{--sidebar-bg-color:#333;--sidebar-img-border-color:#515151;--sidebar-p-color:#909090;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#5a5a5a;--link-color:#268bd2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#fff;--code-background-color:#333333;--moon-sun-color:#FFF;--moon-sun-background-color:#515151}body.dark-theme{--text-color:#eee;--bkg-color:#333;--post-title-color:#DBE2E9;--list-color:#9d9d9d;--link-color:#268bd2;--date-color:#9a9a9a;--table-border-color:#515151;--table-stripe-color:#202020;--code-color:#eee;--code-background-color:#2a2a2a}body{background-color:var(--bkg-color)}</style></head><body><div class=wrapper><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark align=right><button class=btn-light-dark title="Toggle light/dark mode"><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button></div><div class=sidebar-about><h1 class=brand><a href=https://rokkerruslan.github.io><h1>Кот Не Работает</h1></a></h1><p class=lead>Сказки для инженеров-программистов младшего уровня</p></div><nav><ul class=sidebar-nav><li class=heading><a href=/posts/>Заметки</a></li><li class=sub-heading></li><li class=bullet><a href=https://rokkerruslan.github.io/posts/bytes-and-strings/>А как же строки?</a></li></ul></nav><a target=_blank class=social title=GitHub href=https://github.com/rokkerruslan><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2 24 24"><path fill="currentcolor" d="M18.88 1.099C18.147.366 17.265.0 16.233.0H3.746C2.714.0 1.832.366 1.099 1.099.366 1.832.0 2.714.0 3.746v12.487c0 1.032.366 1.914 1.099 2.647.733.733 1.615 1.099 2.647 1.099H6.66c.19.0.333-.007.429-.02a.504.504.0 00.286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555.0 01-.904-.091 2.026 2.026.0 01-.872-.39 1.651 1.651.0 01-.572-.8l-.13-.3a3.25 3.25.0 00-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956.0 01-.17-.156.723.723.0 01-.117-.182c-.026-.061-.004-.111.065-.15.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1.0 01.631.677c.2.355.44.626.722.813.282.186.566.28.852.28.286.0.533-.022.742-.065a2.59 2.59.0 00.585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907.0 01-1.333-.234 5.314 5.314.0 01-1.223-.507 3.5 3.5.0 01-1.047-.872c-.277-.347-.505-.802-.683-1.365-.177-.564-.266-1.215-.266-1.952.0-1.049.342-1.942 1.027-2.68-.32-.788-.29-1.673.091-2.652.252-.079.625-.02 1.119.175.494.195.856.362 1.086.5.23.14.414.257.553.352a9.233 9.233.0 012.497-.338c.859.0 1.691.113 2.498.338l.494-.312a6.997 6.997.0 011.197-.572c.46-.174.81-.221 1.054-.143.39.98.424 1.864.103 2.653.685.737 1.028 1.63 1.028 2.68.0.737-.089 1.39-.267 1.957-.177.568-.407 1.023-.689 1.366a3.65 3.65.0 01-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9.0 01-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36.0 00.208.189c.096.034.18.056.254.064.074.01.18.013.318.013h2.914c1.032.0 1.914-.366 2.647-1.099.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/></svg></a><a target=_blank class=social title=LinkedIn href=https://linkedin.com/in/rokkerruslan><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 448 512"><path fill="currentcolor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg></a><a target=_blank class=social title=Matrix href=https://matrix.to/#/@rokkerruslan:matrix.org><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 27.9 32"><path fill="currentcolor" d="m27.1 31.2v-30.5h-2.19v-.732h3.04v32h-3.04v-.732z"/><path fill="currentcolor" d="m8.23 10.4v1.54h.044c.385-.564.893-1.03 1.49-1.37.58-.323 1.25-.485 1.99-.485.72.0 1.38.14 1.97.42.595.279 1.05.771 1.36 1.48.338-.5.796-.941 1.38-1.32.58-.383 1.27-.574 2.06-.574.602.0 1.16.074 1.67.22.514.148.954.383 1.32.707.366.323.653.746.859 1.27.205.522.308 1.15.308 1.89v7.63h-3.13v-6.46c0-.383-.015-.743-.044-1.08-.0209-.307-.103-.607-.242-.882-.133-.251-.336-.458-.584-.596-.257-.146-.606-.22-1.05-.22-.44.0-.796.085-1.07.253-.272.17-.485.39-.639.662-.159.287-.264.602-.308.927-.052.347-.078.697-.078 1.05v6.35h-3.13v-6.4c0-.338-.007-.673-.021-1-.0114-.314-.0749-.623-.188-.916-.108-.277-.3-.512-.55-.673-.258-.168-.636-.253-1.14-.253-.198.0083-.394.042-.584.1-.258.0745-.498.202-.705.374-.228.184-.422.449-.584.794-.161.346-.242.798-.242 1.36v6.62h-3.13v-11.4z"/><path fill="currentcolor" d="m.936.732v30.5h2.19v.732h-3.04v-32h3.03v.732z"/></svg></a><a target=_blank class=social title=Email href=mailto:rokkerruslan@protonmail.com><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 485.211 485.211"><path fill="currentcolor" d="M301.393 241.631 464.866 424.56H20.332l163.474-182.928 58.801 51.443 58.786-51.444zM462.174 60.651H23.027l219.579 192.142L462.174 60.651zM324.225 221.67l160.986 180.151V80.792L324.225 221.67zM0 80.792v321.029L160.972 221.64.0 80.792z"/></svg></a></div></aside><main class="content container"><div class=post><div class=info><h1 class=post-title><a href=https://rokkerruslan.github.io/posts/bytes-and-strings/>А как же строки?</a></h1><time datetime=2023-05-20T00:00:00Z class=post-date>May 20, 2023</time></div><p>Вне всякого сомнения, самое сложное в программировании — это
именование переменных и <em>что-то там про кеш</em>.
Самое сложное в написании статьи — это написать введение. Нельзя же начинать
с того, что бросить в читателя кусок случайного кода.</p><p>Это экспериментальная заметка. Я буду признателен за любой фидбек.</p><p>Все правки, очепятки и откровенные ошибки отправляйте на электронный
адрес <a href=mailto:rokkerruslan@protonmail.com>rokkerruslan@protonmail.com</a>
, я исправлю это. Также можно внести правки
самостоятельно через <a href=https://github.com/rokkerruslan/gobuch/pulls target=_blank>Pull Request</a>
.
Буду рад. Стараюсь, как могу, не сильно глубоко уходить в детали и не
распыляться по многим темам одновременно, чтобы сохранить некоторую целостность
в повествовании и темп рассказа. Сноски содержат более подробное описание
блока, его пояснение (или ещё больше запутывают). По ним можно проходить и
понять, что имелось в виду в том или ином пункте, если этот пункт в статье
показался неочевидным. Также сноски содержат ссылки на дополнительные источники
информации<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Также укажу, кто есть аудитория статьи. Это программисты на Go, желающие лучше
понять механизм работы встроенных типов данных, а именно — строк и слайсов байт
(далее просто слайсов).</p><p>Я рекомендую экспериментировать с примерами самостоятельно до момента полного
его понимания.</p><p>Вполне вероятно, что примеры, результат выполнения той или иной команды будет
зависеть от версии компилятора и операционной системы, я запускаю на:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>go env GOVERSION GOARCH GOOS
</span></span><span style=display:flex><span>devel go1.19
</span></span><span style=display:flex><span>amd64
</span></span><span style=display:flex><span>linux
</span></span></code></pre></div><p>С введением всё.</p><h2 id=чсть-1-поствведение>Чсть 1. Поствведение</h2><p>Преобразование одних данных в другие это одна из самых распространённых задач в
программировании. Пример, с которого мы начнём, не будет отличаться оригинальностью или вычурностью.
Он вполне банален, вы, скорее всего, не раз делали это самостоятельно.
Есть список байт, мы получили его из некоего источника, нужно преобразовать массив в число.
Последовательности
байт будут содержать закодированные <a href=https://en.wikipedia.org/wiki/UTF-8 target=_blank>utf-8</a>
,
целые, неотрицательные, 64-битные числа в десятичной системе счисления.</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	input <span style=color:#ff7b72;font-weight:700>:=</span> [][]<span style=color:#ff7b72>byte</span>{
</span></span><span style=display:flex><span>		{<span style=color:#a5d6ff>0x31</span>, <span style=color:#a5d6ff>0x32</span>, <span style=color:#a5d6ff>0x33</span>}, <span style=color:#8b949e;font-style:italic>// 1 2 3
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>		{<span style=color:#a5d6ff>0x34</span>, <span style=color:#a5d6ff>0x35</span>, <span style=color:#a5d6ff>0x36</span>}, <span style=color:#8b949e;font-style:italic>// 4 5 6
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>for</span> i <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#ff7b72>range</span> inputs {
</span></span><span style=display:flex><span>		println(string(input[i])) <span style=color:#8b949e;font-style:italic>// Нам нужно преобразовать в число значение inputs[i].
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// go run main.go
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 123
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 456
</span></span></span></code></pre></div><p>Структура данных представляющая последовательность байт в языке Go это
<a href=https://go.dev/ref/spec#Array_types target=_blank>Array</a>
и реализованный на его базе тип
<a href=https://go.dev/ref/spec#Slice_types target=_blank>Slice</a>
, slice может изменять размер в
процессе работы программы. Некоторые
примеры требуют изменения размера, поэтому мы
используем именно его.
С типами входных данных определились, едем дальше.</p><p>Алгоритм. На каждой итерации цикла копируем из источника данные в заранее выделенное место,
обрабатываем их, преобразуя в <em>число</em>, далее проводим вычисления с этим числом.
В первом приближении решение будет выглядеть так<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// allocate buf
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// loop
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	n, err <span style=color:#ff7b72;font-weight:700>:=</span> source.<span style=color:#d2a8ff;font-weight:700>ReadFrom</span>(buf[:])
</span></span><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	nn, err <span style=color:#ff7b72;font-weight:700>:=</span> strconv.<span style=color:#d2a8ff;font-weight:700>ParseUint</span>(buf[:n], <span style=color:#a5d6ff>10</span>, <span style=color:#a5d6ff>64</span>)
</span></span><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>// use nn
</span></span></span></code></pre></div><p>Всё хорошо, только этот код не компилируется &ndash; <a href=https://go.dev/play/p/EAMjZgNOB6J target=_blank>(playground)</a>
.
Всё дело в несовпадении типа аргумента <code>buf[:n]</code> и типа параметра функции
<a href=https://pkg.go.dev/strconv#ParseUint target=_blank>ParseUint</a>
, <em>byte-slice</em> и
<a href=https://go.dev/ref/spec#String_types target=_blank>string</a>
соответственно. Функции
пакета <code>strconv</code> предназначены для обработки строк, но не со слайсами,
даже название намекает, <code>strconv</code> расшифруем как <em>строка, конвертируй</em>.</p><p>Для того чтобы понять что делать дальше, нужно погуглить <a href=https://go.dev/ref/spec target=_blank>ref/spec</a>
по ключевым словам <code>slice</code>, <code>string</code>, <code>conversion</code>.
И в Go есть механизм, позволяющий <em>изменить</em> один тип данных на другой, называется он —
<a href=https://go.dev/ref/spec#Conversions target=_blank>Type Conversions</a>
. Синтаксис одинаков
для всех пар типов, имя типа, выражение в скобках — <code>Type(Expression)</code>. Правило,
по которому происходит конверсия,
отличается от пары к паре (если оно вообще реализовано).
Необходимое нам правило есть в языке:</p><blockquote><p>Converting a slice of bytes to a string type yields a string whose successive bytes are the elements of the slice.</p></blockquote><p>Конверсия слайса в строку <em>выращивает</em> строку, байты которой есть элементы слайса.
Даём байты получаем строку, то, что нужно, воспользуемся конверсией:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#ffa198;background-color:#490202>- v, err := strconv.ParseUint(buf[:n], 10, 64)
</span></span></span><span style=display:flex><span><span style=color:#ffa198;background-color:#490202></span><span style=color:#56d364;background-color:#0f5323>+ v, err := strconv.ParseUint(string(buf[:n]), 10, 64)
</span></span></span></code></pre></div><p>Да, теперь компилируется. Это корректный и быстрый код. А быстрый ли? С точки зрения
производственной среды — да, он ведь не светится, как светодиодные игрушки на
новогодней ёлке, в отчете
профилировщика. И я намеренно не привожу бенчмарки сферических примеров в
вакууме, потому что оптимизацией следует заниматься не на основе результатов
бенчмарков и уж точно не потому, что вы знаете что эта конструкция может работать неэффективно,
а только на основе отчётов инструмента <code>pprof</code>, снятых с работающего приложения.</p><p>Но вопрос остаётся. Если вы всё же увидели этот блок кода в профилировщике?
Насколько быстрый это код? Делает ли он лишние вычисления?
Что он вообще делает?</p><p>Вернёмся и прочитаем ещё раз:</p><blockquote><p>Converting a slice of bytes to a string type yields a string whose successive bytes are the elements of the slice.</p></blockquote><p><em>Создаёт строку</em>, <em>последовательность байт совпадает с элементами слайса</em>. Это
похоже на определение, определение — не алгоритм, из него совершенно
не ясно что конкретно делает Go. Правило не говорит о реализации,
оставляя пространство для оптимизации в будущем, что правильно,
но мы вольны изучать реализацию.</p><p>Сейчас пока мы не можем предполагать насколько сложная будет реализация. Какую часть на
себя берёт компилятор, а какую часть — runtime<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. Если вспомнить, что слайс
изменяемая структура данных, а строка — нет, то
возникает вопрос — как превратить изменяемую в неизменяемую?</p><p>Если зажать клавишу <em>Ctrl</em> и кликнуть на <code>ParseUint</code>, мы попадём<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> на
реализацию функции <code>ParseUint</code>. Но точно такой-же
клик на слово <code>string</code> приводит нас в файл <code>builtin.go</code>, документация которого
говорит, что:</p><blockquote><p>The items documented here are not actually in package builtin</p></blockquote><p>Если тут нет, искать нужно в другом месте. Другой способ — это посмотреть
на готовую программу и её машинный код. Или ещё лучше попросить
компилятор предоставить нам промежуточное ассемблерное представление, а
не исполняемый файл. Прелесть современных инструментов программиста.</p><p>Один из вариантов для Go — это запуск команды <code>GOOS=linux GOARCH=amd64 go build -gcflags=-S</code><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.
Выводит много информации, которая сейчас нам неинтересна, нас интересует только момент
вызова функции <code>strconv.ParseUint</code> и <em>вычисление её аргументов</em>, так как строка это
один из аргументов функции.</p><p>Подготовка аргументов в вызов функции:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-asm data-lang=asm><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>// strconv.ParseUint(string(buf[:n]), 10, 64)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>	<span style=color:#d2a8ff;font-weight:700>CALL</span>	<span style=color:#79c0ff;font-weight:700>runtime.slicebytetostring</span> <span style=color:#8b949e;font-style:italic>; После вызова регистры AX/BX будут содержать строку.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	<span style=color:#d2a8ff;font-weight:700>MOVL</span>	<span style=color:#79c0ff;font-weight:700>$10</span>, <span style=color:#79c0ff;font-weight:700>CX</span> <span style=color:#8b949e;font-style:italic>; Положить число 10 в регистр C
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	<span style=color:#d2a8ff;font-weight:700>MOVL</span>	<span style=color:#79c0ff;font-weight:700>$64</span>, <span style=color:#79c0ff;font-weight:700>DI</span> <span style=color:#8b949e;font-style:italic>; Положить число 64 в регистр D
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	<span style=color:#d2a8ff;font-weight:700>CALL</span>	<span style=color:#79c0ff;font-weight:700>strconv.ParseUint</span>
</span></span></code></pre></div><p>Обратить внимание нужно только на вызов функции <code>runtime.slicebytetostring</code>. Именно
эта функция конвертирует байт слайс в строку<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>.</p><p>Это уже то, что можно найти в исходном коде. Без некоторых лишних деталей её реализация выглядит так<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>slicebytetostring</span>(buf <span style=color:#ff7b72;font-weight:700>*</span>tmpBuf, ptr <span style=color:#ff7b72;font-weight:700>*</span><span style=color:#ff7b72>byte</span>, n <span style=color:#ff7b72>int</span>) (str <span style=color:#ff7b72>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>var</span> p unsafe.Pointer
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>if</span> buf <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>nil</span> <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> n <span style=color:#ff7b72;font-weight:700>&lt;=</span> len(buf) {
</span></span><span style=display:flex><span>		p = unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(buf)
</span></span><span style=display:flex><span>	} <span style=color:#ff7b72>else</span> {
</span></span><span style=display:flex><span>		p = <span style=color:#d2a8ff;font-weight:700>mallocgc</span>(uintptr(n), <span style=color:#79c0ff>nil</span>, <span style=color:#79c0ff>false</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#d2a8ff;font-weight:700>stringStructOf</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>str).str = p
</span></span><span style=display:flex><span>	<span style=color:#d2a8ff;font-weight:700>stringStructOf</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>str).len = n
</span></span><span style=display:flex><span>	<span style=color:#d2a8ff;font-weight:700>memmove</span>(p, unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(ptr), uintptr(n))
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Сначала мы проверяем, выдали ли нам буфер, куда мы поместим содержание строки,
если нет или длина буфера недостаточна, runtime выделит в куче пространство для
строки. Что же мы видим?</p><ul><li>Потенциальное выделенеи памяти — <code>mallocgc</code>.</li><li>Копирование участка памяти — <code>memmove</code>.</li></ul><p>Наша задача не предполагает использование старого значения слайса
(число уже распаршено и обработано) после завершения очередной итерации цикла, и, также не предполагает
дальнейшее использование строки. Слайс байт мы можем переиспользовать явно, а что со строкой?</p><p>Мы всё равно её конструируем, выделяем память (в некоторых случаях),
копируем содержимое слайса в место, выделенное под строку (безальтернативно).
И так на каждой итерации. Нагружаем runtime бесполезной работой,
на работу аллокатора требуется CPU, на отслеживание выделенных объектов и их
дальнейшее освобождение сборщиком мусора так же тратит ресурсы CPU.</p><h2 id=чсть-2-что-такое-строки-и-что-такое-байты>Чсть 2. Что такое строки и что такое байты</h2><blockquote><p>И ассемблер и рантайм. Энто сложно. Прекращай!
А меж тем сказке — далеко до развязки!..</p></blockquote><p>Мы удовлетворяем требование типа параметра функции <code>strconv.ParseUint</code>, и более нам
не нужно значение типа <code>string</code>. Отсюда вытекает наше предположение, а можем
ли мы попробовать не вызывать функцию <code>slicebytetostring</code>? Не использовать
синтаксическую конструкцию <em>string(X)</em>. Как ещё можно преобразовать один тип
в другой?</p><p>Мы уже знаем, что строки — это просто последовательности байт, нет необходимости
проводить сложные вычисления при создании строки. Как, например, убедиться что
последовательность байт — это валидная строка в <em>utf-8</em>. Это, как минимум в
теории, делает возможным преобразование значений с минимальными потерями в
производительности.</p><p>Можно ли заставить компилятор интерпретировать некоторый участок
памяти, выделенный под слайс, как строку? Для этого нужно исследовать
их внутреннее представление более тщательно.</p><p>Для начала посмотрим их представление
в коде языка. Объявление типов находятся в пакете <em>runtime</em>:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// runtime/slice.go
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>type</span> slice <span style=color:#ff7b72>struct</span> {
</span></span><span style=display:flex><span>	array unsafe.Pointer
</span></span><span style=display:flex><span>	len   <span style=color:#ff7b72>int</span>
</span></span><span style=display:flex><span>	cap   <span style=color:#ff7b72>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// runtime/string.go
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>type</span> stringStruct <span style=color:#ff7b72>struct</span> {
</span></span><span style=display:flex><span>	str unsafe.Pointer
</span></span><span style=display:flex><span>	len <span style=color:#ff7b72>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Слайс это структура с тремя полями — <code>unsafe.Pointer</code>, <code>int</code>, <code>int</code>. Тип <code>unsafe.Pointer</code>
в свою очередь — это указатель на произвольный тип, что такое этот произвольный тип
тут не важно, нам достаточно, что это указатель:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>type</span> Pointer <span style=color:#ff7b72;font-weight:700>*</span>ArbitraryType <span style=color:#8b949e;font-style:italic>// type ArbitraryType int
</span></span></span></code></pre></div><p>Указатель на 64-битной системе равен 8-ми байтам. Два int-а это ещё 16 байт. Итого 24
байта на один слайс. Строка это два поля, также указатель на данные — <code>unsafe.Pointer</code>
и длина строки int всего 16 байт, ёмкости у строк нет.</p><p>Предположим, мы обманули компилятор и заставили его работать со слайсом как со
строкой. Сработает ли это? Для наглядности попробуем поработать не с абстрактным
описанием структур в тексте программы, а с реальными значениями.</p><p>Наш полигон:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>foobar</span> () {
</span></span><span style=display:flex><span>	a <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#a5d6ff>&#34;foobar&#34;</span>
</span></span><span style=display:flex><span>	b <span style=color:#ff7b72;font-weight:700>:=</span> []byte(string(<span style=color:#a5d6ff>&#34;foobar&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span></code></pre></div><p>Ниже представлена открытая сессия <a href=https://github.com/go-delve/delve target=_blank>delve</a>
отладчика. В локальном окружении функции есть две переменные <code>a</code> и <code>b</code>, <code>а</code> строка,
<code>b</code> — это слайс (uint8 — это подтип типа byte). Для просмотра локальных
переменных есть команда <em>locals</em>:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>(dlv) locals
</span></span><span style=display:flex><span>  a = &#34;foobar&#34;
</span></span><span style=display:flex><span>  b = []uint8 len: 6, cap: 6, [...]
</span></span></code></pre></div><p>Значение строки нам показывают, значение слайса мы не видим, указывается
только длина и ёмкость. Не очень понятное представление. Неясно, что это лежит в памяти.
Локальное окружение функции, а точнее сказать <em>кадр стека</em> тоже объект,
выполнив команду <code>frame 0</code>, мы увидим его визуализацию:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>(dlv) frame 0
</span></span><span style=display:flex><span>&gt; main.foobar() ./main.go:9 (hits goroutine(1):1 total:1) (PC: 0x45fa02)
</span></span><span style=display:flex><span>Frame 0: ./main.go:9 (PC: 45fa02)
</span></span><span style=display:flex><span>     4:	func foobar() {
</span></span><span style=display:flex><span>     5:		a := &#34;foobar&#34;
</span></span><span style=display:flex><span>     6:		b := []byte(string(&#34;foobar&#34;))
</span></span><span style=display:flex><span>     7:	
</span></span><span style=display:flex><span>     8:		// ...
</span></span><span style=display:flex><span>=&gt;   9:		println(a, b)
</span></span><span style=display:flex><span>    10:	}
</span></span><span style=display:flex><span>    11:	
</span></span><span style=display:flex><span>    12:	func main() {
</span></span><span style=display:flex><span>    13:		foobar()
</span></span><span style=display:flex><span>    14:	}
</span></span></code></pre></div><p>Никакой нужной нам информации нет. Можно вычислить адрес кадра стека
и после вычленить оттуда значения a и b, но намного проще получить
адреса переменных в памяти и инспектировать уже её.</p><p>Адреса переменных можно получить так:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>(dlv) print unsafe.Pointer(&amp;a)
</span></span><span style=display:flex><span>  (unsafe.Pointer)(0xc000052720)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(dlv) print unsafe.Pointer(&amp;b)
</span></span><span style=display:flex><span>  (unsafe.Pointer)(0xc000052730)
</span></span></code></pre></div><p>Так как мы уже видели выше, строка это указатель и <em>int</em>. И указатель, и <code>int</code> на 64-битной
системе равны восьми байтам. Восемь плюс восемь будет 16.</p><p>Значит, чтобы вычитать значение строки, нужно прочитать 16 байт начиная с адреса
переменной <code>a</code> с помощью команды <em>examinemem</em>:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>(dlv) examinemem -fmt hex -size 1 -count 16 0xc000052720
</span></span><span style=display:flex><span>  0xc000052720:   0x68   0xf6   0x46   0x00   0x00   0x00   0x00   0x00   
</span></span><span style=display:flex><span>  0xc000052728:   0x06   0x00   0x00   0x00   0x00   0x00   0x00   0x00
</span></span></code></pre></div><p>Моя машина — little-endian<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> машина. По младшему адресу <code>0xc000052720</code> хранится младший байт
указателя на строку это <em>0x68</em>, по адресу старшему <code>0xc000052727</code> старший байт указателя — <em>0x00</em>.
По адресу <code>0xc000052728</code>
находится младший байт значения длины — <em>0x06</em>, по адресу <code>0xc00005272f</code> — старший
байт поля <code>len</code> — <code>0x00</code>. Чтобы отобразить их в человеко-понятном виде, нужно выписать
значения задом наперёд, без пробелов и каких либо разделительных знаков (так как я привык ставить старший разряд
левее младшего, а не наоборот). Или попросить <code>delve</code> отобразить значение с учётом размера,
размер при этом нужно указать самостоятельно, так как размеры одинаковы, там и там по 8 байт,
попросим 2 раза по 8 байт:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>(dlv) examinemem -fmt hex -size 8 -count 2 0xc000052720
</span></span><span style=display:flex><span>  0xc000052720:   0x000000000046f668   0x0000000000000006
</span></span></code></pre></div><p>Первые 8 байт это указатель на строку, по нему тоже можно пройтись и
посмотреть что там лежит:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>(dlv) examinemem -fmt hex -size 1 -count 6 0x000000000046f668
</span></span><span style=display:flex><span>  0x46f668:   0x66   0x6f   0x6f   0x62   0x61   0x72 // f o o b a r -&gt; foobar
</span></span></code></pre></div><p>Судя по документации delve не поддерживает формат char или что-то вроде того,
так что декодируйте в уме.</p><p>Так хорошо, со строками разобрались, а что из себя представляет байт слайс?</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>(dlv) examinemem -fmt hex -size 1 -count 24 0xc000052730
</span></span><span style=display:flex><span>  0xc000052730:   0x12   0x27   0x05   0x00   0xc0   0x00   0x00   0x00   
</span></span><span style=display:flex><span>  0xc000052738:   0x06   0x00   0x00   0x00   0x00   0x00   0x00   0x00   
</span></span><span style=display:flex><span>  0xc000052740:   0x06   0x00   0x00   0x00   0x00   0x00   0x00   0x00 
</span></span></code></pre></div><p>Так, первые 16 байт это тоже адрес и длина. По адресу <code>0xc000052740</code> хранится
ёмкость слайса.</p><p>А если с этого адреса прочитать только два байта? Вы можете ответить на вопрос, это строка
лежит или слайс байт?</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>(dlv) examinemem -fmt hex -size 8 -count 2 0xc000052730
</span></span><span style=display:flex><span>  0xc000052730:   0x000000c000052712   0x0000000000000006
</span></span></code></pre></div><p>Всё это наводит на мысль, что мы можем представить слайс как строку. Если
попытаться обмануть компилятор, сказать - <em>ты сейчас обращаешься к строке</em>
подсунув при этом ему участок памяти где лежит слайс, он точно ничего не заметит.
Сломать систему типов может быть непросто. Начинать, как и всегда, стоит с
документации. В этот раз искать по ключевым словам <code>type system</code> и <code>violate</code>.</p><p>В самом конце спецификации (это видимо чтобы подольше не находили) читаем:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>The built-in package unsafe, known to the compiler and accessible through the
</span></span><span style=display:flex><span>import path &#34;unsafe&#34;, provides facilities for low-level programming including
</span></span><span style=display:flex><span>operations that violate the type system.
</span></span></code></pre></div><p>О, да. Кажется, слова <em>нарушение системы типов</em> и есть те заветные слова, что мы ищем.
Следующие параграфы проясняют <em>как именно</em> можно её (систему типов) поломать:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>A Pointer is a pointer type but a Pointer value may not be dereferenced. Any
</span></span><span style=display:flex><span>pointer or value of underlying type uintptr can be converted to a type of
</span></span><span style=display:flex><span>underlying type Pointer and vice versa.
</span></span></code></pre></div><p>Так, то есть это предложение, в том числе, говорит нам о том, что любой
указатель может быть преобразован в тип, <em>underlying type</em> которого есть тип Pointer,
<em>underlying type</em> типа Pointer тоже Pointer. Наш алгоритм преобразования будет такой:</p><ul><li>Взять слайс.</li><li>Взять указатель на это значение путём операции взятия адреса - <code>&</code>, теперь у нас
есть указатель на слайс.</li><li>Конвертировать указатель на слайс в <code>unsafe.Pointer</code>.</li><li>Конвертировать <code>unsafe.Pointer</code> в указатель на строку.</li><li>Разыменовать указатель на строку и получить строку<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>.</li></ul><p>По шагам в коде:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span>buf <span style=color:#ff7b72;font-weight:700>:=</span> []<span style=color:#ff7b72>byte</span>{<span style=color:#a5d6ff>&#39;H&#39;</span>, <span style=color:#a5d6ff>&#39;e&#39;</span>, <span style=color:#a5d6ff>&#39;l&#39;</span>, <span style=color:#a5d6ff>&#39;l&#39;</span>}
</span></span><span style=display:flex><span>pointerToByteSlice <span style=color:#ff7b72;font-weight:700>:=</span> unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>buf)
</span></span><span style=display:flex><span>pointerToString <span style=color:#ff7b72;font-weight:700>:=</span> (<span style=color:#ff7b72;font-weight:700>*</span><span style=color:#ff7b72>string</span>)pointer
</span></span><span style=display:flex><span>str <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#ff7b72;font-weight:700>*</span>pointerToString
</span></span><span style=display:flex><span>fmt.<span style=color:#d2a8ff;font-weight:700>Printf</span>(<span style=color:#a5d6ff>&#34;val=%q type=%T\n&#34;</span>, str, str) <span style=color:#8b949e;font-style:italic>// val=&#34;Hell&#34; type=string
</span></span></span></code></pre></div><p>Когда runtime пойдёт брать длину строки, так же отсчитает 8 байт от начала и
прочитает 8 байт где найдёт длину строки. А когда возьмёт 8 байт начиная с 0, он
обнаружит адрес, по которому лежат байты нашей строки. Как мы видели в реализации
функции <code>slicebytetostring</code> содержимое слайса байт не проходит никакой обработки
и не может завершиться неудачей<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>.</p><p>Однострочная версия:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span>buf <span style=color:#ff7b72;font-weight:700>:=</span> []<span style=color:#ff7b72>byte</span>{<span style=color:#a5d6ff>&#39;1&#39;</span>, <span style=color:#a5d6ff>&#39;2&#39;</span>, <span style=color:#a5d6ff>&#39;3&#39;</span>, <span style=color:#a5d6ff>&#39;4&#39;</span>}
</span></span><span style=display:flex><span>v, err <span style=color:#ff7b72;font-weight:700>:=</span> strconv.<span style=color:#d2a8ff;font-weight:700>ParseUint</span>(<span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72;font-weight:700>*</span><span style=color:#ff7b72>string</span>)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>buf)), <span style=color:#a5d6ff>10</span>, <span style=color:#a5d6ff>64</span>)
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>check</span>(err)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fmt.<span style=color:#d2a8ff;font-weight:700>Printf</span>(<span style=color:#a5d6ff>&#34;type=%T val=%v&#34;</span>, v, v) <span style=color:#8b949e;font-style:italic>// type=uint64 val=1234
</span></span></span></code></pre></div><p>А без unsafe можно? Нет.
Правила конверсии указателя на слайс в указатель на строку не существует. Как-то так:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>(*string)(&amp;buf)                 // Cannot convert an expression of the type &#39;*[]byte&#39; to the type &#39;*string&#39;
</span></span><span style=display:flex><span>(*string)(unsafe.Pointer(&amp;buf)) // This is fine 🔥
</span></span></code></pre></div><p>Что мы получаем в итоге. Вызов функции <code>slicebytetostring</code>, потенциальную аллокацию и копирование
заменено взятием адреса и разыменованием:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-asm data-lang=asm><span style=display:flex><span>  <span style=color:#d2a8ff;font-weight:700>MOVQ</span>  <span style=color:#a5d6ff>32</span>(<span style=color:#79c0ff;font-weight:700>SP</span>),  <span style=color:#79c0ff;font-weight:700>AX</span>     <span style=color:#8b949e;font-style:italic>; Взять адрес и положить в AX
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#d2a8ff;font-weight:700>MOVQ</span>  <span style=color:#79c0ff;font-weight:700>AX</span>,      <span style=color:#a5d6ff>24</span>(<span style=color:#79c0ff;font-weight:700>SP</span>) <span style=color:#8b949e;font-style:italic>; Сохранить адрес в SP по смещению 24
</span></span></span></code></pre></div><p>Этого точно не будет в отчёте <code>pprof</code>.</p><h2 id=чсть-3-а-как-же-строки>Чсть 3. А как же строки?</h2><blockquote><p><em>— А как же строки, строки? Руслан.</em>
<em>— Какие ещё строки?</em>
<em>— Ты перечислял неизменяемые типы, почему не упомянул строки?</em>
<em>— А это из другой сказки.</em></p></blockquote><p>Все эти операции немного расшатывают наше представление о том, что строки
являются неизменяемыми структурами данных. Мы не только ссылаемся на один
и тот же массив, но и переиспользуем заголовок слайса байт как заголовок строки.
Это может означать только одно — они изменяемы. Документация же явно говорит что нет:</p><blockquote><p>Strings are immutable: once created, it is impossible to change the contents of a string.</p></blockquote><p>Может быть те строки что мы строим из слайса <em>не настойщие</em>? Попытаемся пойти обратной
дорогой и начать вот с этих самых <em>не изменяемых</em> строк. Например, что на счёт
<a href=https://go.dev/ref/spec#String_literals target=_blank>литерала</a>
строки?</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>here := &#34;Hello, Go!&#34;
</span></span><span style=display:flex><span>here[0] = 1 // Compile time error: Cannot assign to here[0]
</span></span></code></pre></div><p>И правда. Менять содержимое строки не даёт ещё даже компилятор.</p><blockquote><p><em>Ты когда нибудь Segmentation Fault на Go видел? И я не видел, а он — есть<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup></em>:</p></blockquote><p>Мы уже научились конвертировать слайсы в строки, что если действовать по аналогии?
Создадим слайс совместно использующий нижележащий массив вместе со
строкой. Компилятор же не будет против изменения слайса?</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> <span style=color:#a5d6ff>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	s <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#a5d6ff>&#34;Hello, Go!&#34;</span>
</span></span><span style=display:flex><span>	b <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72;font-weight:700>*</span>[]<span style=color:#ff7b72>byte</span>)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>s))
</span></span><span style=display:flex><span>	b[<span style=color:#a5d6ff>0</span>] = <span style=color:#a5d6ff>&#39;X&#39;</span> <span style=color:#8b949e;font-style:italic>// unexpected fault address 0x100ebfe77
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span></code></pre></div><p>Компилятор откомпилировал, но ошибка (фатальная) уже
при исполнении. Это вполне способно разбудить вас ночью,
но программисты не спят — идём дальше:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	s <span style=color:#ff7b72;font-weight:700>:=</span> string([]byte(<span style=color:#a5d6ff>&#34;Hello, Go!&#34;</span>)) <span style=color:#8b949e;font-style:italic>// Кто в Text Segment не спрятался, я не виноват.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	b <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72;font-weight:700>*</span>[]<span style=color:#ff7b72>byte</span>)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>s))
</span></span><span style=display:flex><span>	b[<span style=color:#a5d6ff>0</span>] = <span style=color:#a5d6ff>&#39;X&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#d2a8ff;font-weight:700>Println</span>(s) <span style=color:#8b949e;font-style:italic>// Xello, Go!
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span></code></pre></div><p>Это работает, Гарольд. Получается что не все строки в программе такие уж и
неизменяемые, некоторое подмножество строк, живущих в программе, изменить можно,
<a href=https://go.dev/play/p/YeZAO4Mhmdy target=_blank>Playground</a>
. Изменяемы те, кто живёт в куче,
не изменяемы те, что живет в коде программы<sup id=fnref:12><a href=#fn:12 class=footnote-ref role=doc-noteref>12</a></sup>.</p><p>Конструкция <code>[]byte(&lt;str>)</code> заставляет компилятор вставить процедуру аналогичную <code>slicebytetostring</code>
и в изменяемой памяти процесса появится массив, равный длине строки, куда будут скопированы
элементы строки (из сегмента неизменяемой памяти). Преобразование результата в строку так же
происходит уже во время выполнения программы и runtime-у нужно сконструировать строку
из слайса, поэтому она уже не может быть помещена в сегмент неизменяемой памяти.</p><p>Версия для <a href=https://go.dev/play/p/MNwXW4k9wxw target=_blank>собеседований</a>
. Запомните или запишите:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	buf <span style=color:#ff7b72;font-weight:700>:=</span> strings.Builder{}
</span></span><span style=display:flex><span>	buf.<span style=color:#d2a8ff;font-weight:700>WriteString</span>(<span style=color:#a5d6ff>&#34;Go strings are immutable&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	out <span style=color:#ff7b72;font-weight:700>:=</span> buf.<span style=color:#d2a8ff;font-weight:700>String</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#d2a8ff;font-weight:700>doit</span>(out) <span style=color:#8b949e;font-style:italic>// Очевидно ничего плохого со строкой не сделает.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#d2a8ff;font-weight:700>Println</span>(out) <span style=color:#8b949e;font-style:italic>// Go strings are mutable
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>doit</span>(s <span style=color:#ff7b72>string</span>) {
</span></span><span style=display:flex><span>	b <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72;font-weight:700>*</span>[]<span style=color:#ff7b72>byte</span>)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>s))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>for</span> i <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#a5d6ff>0</span>; i &lt; <span style=color:#a5d6ff>7</span>; i<span style=color:#ff7b72;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		b[<span style=color:#a5d6ff>15</span><span style=color:#ff7b72;font-weight:700>+</span>i] = b[<span style=color:#a5d6ff>17</span><span style=color:#ff7b72;font-weight:700>+</span>i]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	b[len(b)<span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>2</span>] = <span style=color:#a5d6ff>&#39; &#39;</span>
</span></span><span style=display:flex><span>	b[len(b)<span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>] = <span style=color:#a5d6ff>&#39; &#39;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Шутяки заканчивается когда мы вспоминаем, что байт слайсы изменяемый
тип данных. Например, мы можем растянуть байт слайс до его емкости. Так стоп, а
какая вообще ёмкость у получившегося слайса?</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	here <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#a5d6ff>&#34;Hello &#34;</span>
</span></span><span style=display:flex><span>	here = string([]byte(here))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	out <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72;font-weight:700>*</span>[]<span style=color:#ff7b72>byte</span>)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>here))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#d2a8ff;font-weight:700>Printf</span>(<span style=color:#a5d6ff>&#34;%d %d\n&#34;</span>, len(out), cap(out)) <span style=color:#8b949e;font-style:italic>// 6 1374390628136
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span></code></pre></div><p>Длина равна шести. Ожидаемо. Емкость равна&mldr; Один миллион&mldr; не, один миллиард&mldr; — <em>очень много</em>. Шести не равно.
Ответы 0, 6 и 42 пояснения не требуют, но 1374390628136?</p><p>Мы не создаём <code>[]byte</code> явно. Говоря, что по адресу, к примеру <code>0xff0000</code>, лежит байт слайс
runtime может попытаться считать значение ёмкости по смещению <code>0xff0000</code> плюс <code>0x10</code>. Но этот
участок памяти ему уже не принадлежит. Если заголовок строки находился на стеке функции,
то после заголовка может лежать другая переменная. Если заголовок был выделен в куче, то
участок после заголовка строки может принадлежать совершенно другой переменной, выделенной ранее где-то
в программе.</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>// Заголовок строки в памяти.
</span></span><span style=display:flex><span>0xff0000 0x00000001006a8fd0
</span></span><span style=display:flex><span>0xff0008 0x0000000000000006
</span></span><span style=display:flex><span>// Выделенная память аллокатором для переменной X=1374390628136 в другом участе програмыы.
</span></span><span style=display:flex><span>0xff0010 0x000001400010af28
</span></span></code></pre></div><p>Мы не контролируем значение ёмкости получившегося слайса. Значение может быть совершенно
случайным. В зависимости от того, что уже успел навыделять аллокатор.
Если вы запустите код на своей машине, вывод может быть другим, но точно
сказать, чему будет он равен — нельзя.</p><p>Раз ёмкость не равна длине, а может быть даже больше длины. Значит длину слайса
можно растянуть, например, до сотни:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	here <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#a5d6ff>&#34;Hello &#34;</span>
</span></span><span style=display:flex><span>	here = string([]byte(here))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	out <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72;font-weight:700>*</span>[]<span style=color:#ff7b72>byte</span>)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>here))
</span></span><span style=display:flex><span>	out = out[:<span style=color:#a5d6ff>100</span>]
</span></span><span style=display:flex><span>	fmt.<span style=color:#d2a8ff;font-weight:700>Printf</span>(<span style=color:#a5d6ff>&#34;%d %d\n&#34;</span>, len(out), cap(out)) <span style=color:#8b949e;font-style:italic>// &#34;Hello  @�!@HelloO@&#34;
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span></code></pre></div><p>Ха, участок памяти, где лежит строка &ldquo;Hello " тоже не изолированный. За ним следующие ячейки
памяти, в которых так же хранятся значения других переменных программы.</p><p>Представим что клиент определяет сколько он может ещё получить данных. Распространённая
практика<sup id=fnref:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup>. Ограничение всё равно есть, чтобы не перегрузить сервер. Мы пишем надёжное ПО?</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a5d6ff>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	here <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#a5d6ff>&#34;Hello &#34;</span>
</span></span><span style=display:flex><span>	here = string([]byte(here))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>func</span>() {
</span></span><span style=display:flex><span>		secretparol <span style=color:#ff7b72;font-weight:700>:=</span> string([]byte(<span style=color:#a5d6ff>&#34;lolkekcheburek&#34;</span>)) <span style=color:#8b949e;font-style:italic>// Секретное преобразование для секретного пароля
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>		secretparol <span style=color:#ff7b72;font-weight:700>+=</span> <span style=color:#a5d6ff>&#34;&#34;</span>
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	out <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#ff7b72;font-weight:700>*</span>(<span style=color:#ff7b72;font-weight:700>*</span>[]<span style=color:#ff7b72>byte</span>)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>here))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#d2a8ff;font-weight:700>Printf</span>(<span style=color:#a5d6ff>&#34;%d %d\n&#34;</span>, len(out), cap(out))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#d2a8ff;font-weight:700>Println</span>(string(out))
</span></span><span style=display:flex><span>	out = out[:<span style=color:#a5d6ff>1000000</span>]      <span style=color:#8b949e;font-style:italic>// Я могу получить ещё 1000000. Присылай!
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	fmt.<span style=color:#d2a8ff;font-weight:700>Println</span>(string(out))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Полный вывод:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-text data-lang=text><span style=display:flex><span>6 1374389815144
</span></span><span style=display:flex><span>Hello
</span></span><span style=display:flex><span>Hello �!@(&#34;@(�  @Hello Ў        @Ў      @�zp@�sP:�s
</span></span><span style=display:flex><span>@$@@�!@`)��     @��     @�      @�      @`      @�      @ !     @@��!@�&amp;@@@�@�@��
</span></span><span style=display:flex><span>          ����r �����AQ�&#34;���hdA�I8��hd�r        ��hd�r  ���cr�9�Z�@����r       �����AQ�&#34;���hdA�I8��hd�r        ��hd�r  ���cr�9�
</span></span><span style=display:flex><span>@p
</span></span><span style=display:flex><span>@1374389815144.lolkekcheburekhG@6 Hello // ТУТ КАЖЕТСЯ ЕСТЬ ПАРОЛЬ
</span></span><span style=display:flex><span>89815144
</span></span><span style=display:flex><span>Hello ��px`
</span></span><span style=display:flex><span>@f�f��0�`@0`@�@ �@
</span></span><span style=display:flex><span>���l�r@@``@ �@�`@�`@x�@ H�@ a@
</span></span><span style=display:flex><span>u*���(*�@�@�@�@0�@
</span></span><span style=display:flex><span>@�@               @
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  xY�\�@�`@`�P@/Users/rokkerruslan/w/secret.maxfilesperprocIp // Так, а это что такое? Мак?
</span></span><span style=display:flex><span>@
</span></span></code></pre></div><p>В воздухе витает слово уязвимость и уже давно. Не смотрите что в выводе много лишней информации,
пароли и другие секретные последовательности обычно отличаются от строк в
программе, их легко определить. А некоторые строки вообще по структуре можно
искать, примерно так выглядят все AccessKeyID от AWS — <code>AKETOJOPAGANDAMSTYLE</code>.</p><p>Если вам кажется что это нереалистичный сценарий, то всё-таки кажется. У этого
типа ошибок своё название есть - <a href=https://en.wikipedia.org/wiki/Buffer_overflow target=_blank>Buffer Overflow</a>
.</p><p>Подумаем. Программа может:</p><ul><li><p>Упасть с ошибкой <code>Segmentation Fault</code>, если так выйдет, что при чтении
из слайса мы выйдем из границы адресного пространства выделенного нам ОС.
Программа завершается. И это самое безобидное из всех возможных ситуаций.</p></li><li><p>Как показано выше, атакующий может вычитать область памяти, в которой, в свою очередь,
может присутствовать чувствительная информация, явки/пароли из стека горутины и
стека других горутин в программе. И всё содержимое памяти процесса.</p></li><li><p>Атакующий может изменить чужую область памяти на своё значение. Например, если он знает по
какому смещению живёт оригинал пароля, то может его подменить его своим.</p></li></ul><h2 id=чсть-4-правильный-способ>Чсть 4. &ldquo;Правильный&rdquo; способ</h2><p>Одним из самых лучших способов поднимать свой уровень знаний — это учиться у
старших.</p><p>Компилятор — это не только инструмент для сборки программ на Go, но и
большое множество примеров по написания кода. Если вы
хотите изучить некий алгоритм, начать поиски с исходного
кода компилятора — неплохая точка входа. Нам же даже искать не надо,
мы уже видели нужный нам код.</p><p>Помним что есть функция <code>slicebytetostring</code>. Она выделяет место в памяти для
нижележащего массива, а потом копирует туда элементы исходного массива. Но это
только часть, а что с самой структурой данных заголовка строки?</p><p>Посмотрим на реализацию ещё раз:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>slicebytetostring</span>(buf <span style=color:#ff7b72;font-weight:700>*</span>tmpBuf, ptr <span style=color:#ff7b72;font-weight:700>*</span><span style=color:#ff7b72>byte</span>, n <span style=color:#ff7b72>int</span>) (str <span style=color:#ff7b72>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>var</span> p unsafe.Pointer
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>if</span> buf <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>nil</span> <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> n <span style=color:#ff7b72;font-weight:700>&lt;=</span> len(buf) {
</span></span><span style=display:flex><span>		p = unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(buf)
</span></span><span style=display:flex><span>	} <span style=color:#ff7b72>else</span> {
</span></span><span style=display:flex><span>		p = <span style=color:#d2a8ff;font-weight:700>mallocgc</span>(uintptr(n), <span style=color:#79c0ff>nil</span>, <span style=color:#79c0ff>false</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#d2a8ff;font-weight:700>stringStructOf</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>str).str = p
</span></span><span style=display:flex><span>	<span style=color:#d2a8ff;font-weight:700>stringStructOf</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>str).len = n
</span></span><span style=display:flex><span>	<span style=color:#d2a8ff;font-weight:700>memmove</span>(p, unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(ptr), uintptr(n))
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Заголовок строки создаётся внутри функции <code>slicebytetostring</code>. Поля <code>str</code> и <code>len</code>
заполняются явно, новыми значениями. Значение поля <code>str</code> это указатель на ново-выделенный
участок памяти, значение поля <code>len</code> это длина участка памяти.</p><p>Слово &ldquo;правильный&rdquo; звучит так себе, лучше скажем <em>более безопасный</em>, так вот это
более безопасный способ преобразовать строку в слайс и обратно, без аллокации и копирования
нижележащего массива (но будьте внимательны, спать нельзя даже тут, потому что и
в его использовании можно накосячить<sup id=fnref:14><a href=#fn:14 class=footnote-ref role=doc-noteref>14</a></sup>).</p><p>Идея заключается в том, что мы конструируем заголовки (и строки и слайса)
самостоятельно и копируем поля из структуры из которой мы преобразовываем в
только что созданную структуру.</p><p>Используем подход <code>slicebytetostring</code>, структуры слайса и строки можно найти в
пакете <code>reflect</code>:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:3;-o-tab-size:3;tab-size:3><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Конверсия из слайса в строку.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>btos</span>(in []<span style=color:#ff7b72>byte</span>) (out <span style=color:#ff7b72>string</span>) {
</span></span><span style=display:flex><span>	slice <span style=color:#ff7b72;font-weight:700>:=</span> (<span style=color:#ff7b72;font-weight:700>*</span>reflect.SliceHeader)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>in))
</span></span><span style=display:flex><span>	str <span style=color:#ff7b72;font-weight:700>:=</span> (<span style=color:#ff7b72;font-weight:700>*</span>reflect.StringHeader)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>out))
</span></span><span style=display:flex><span>	str.Data = slice.Data
</span></span><span style=display:flex><span>	str.Len = slice.Len
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>return</span> s
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Конверсия из строки в слайс байт.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>func</span> <span style=color:#d2a8ff;font-weight:700>stob</span>(in <span style=color:#ff7b72>string</span>) (out []<span style=color:#ff7b72>byte</span>) {
</span></span><span style=display:flex><span>	slice <span style=color:#ff7b72;font-weight:700>:=</span> (<span style=color:#ff7b72;font-weight:700>*</span>reflect.SliceHeader)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>out))
</span></span><span style=display:flex><span>	str <span style=color:#ff7b72;font-weight:700>:=</span> (<span style=color:#ff7b72;font-weight:700>*</span>reflect.StringHeader)(unsafe.<span style=color:#d2a8ff;font-weight:700>Pointer</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>in))
</span></span><span style=display:flex><span>	slice.Data = str.Data
</span></span><span style=display:flex><span>	slice.Len = str.Len
</span></span><span style=display:flex><span>	slice.Cap = str.Len
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>return</span> s
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Подход не отличается концептуально, использование unsafe остаётся, формально осталось и
нарушение системы типов, ведь <code>reflect.SliceHeader</code> это не <code>runtime.slice</code>. Если их
представление в памяти не будет совпадать, то будет плохо, хотя это маловероятно и
говорит о баге в коде компилятора/runtime-а.</p><p>Но мы больше не интерпретируем блок памяти от заголовка слайса как блок памяти
заголовка строки. Мы создаём новый заголовок для слайса байт, а далее заполняем
его поля руками. Более ли этот подход устойчивее к ошибке, да, он более устойчив
(нужно упомянуть, вы создаёте новый объект, вы не можете указать компилятору не
выделять объект в куче)<sup id=fnref:15><a href=#fn:15 class=footnote-ref role=doc-noteref>15</a></sup>.</p><p>Сложность реального процесса и изначальное представление строк, как неизменяемых типов, приводит
к тому что функциональности конверсии (без выделения памяти и копирования) нет
в стандартной библиотеке Go, по крайней мере, это так со
<a href=https://github.com/golang/go/issues/25484#issuecomment-390846454 target=_blank>слов разработчиков</a>
.</p><p>Особняком стоит проблема, что язык Go, а именно компилятор языка, не
подталкивает вас к правильному решению<sup id=fnref:16><a href=#fn:16 class=footnote-ref role=doc-noteref>16</a></sup>. Для компилятора все способы одинаковые
пока это компилируется, а как видели мы выше, компилируется не значит работает.
Даже работает значит <em>корректно работает</em>. Корректную же работу должен
обеспечить программист. Не надейтесь, что кот будет работать просто так.</p><h2 id=заключение>Заключение</h2><p>Заключения нет. Делитесь и распространяйте статью. С вас лайк, подписка и, конечно
же, не забудьте нажать на <em>колокольчик</em> дабы не пропустить новые&mldr;</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Кроме первой. Но я больше так не буду, das verspreche ich. Нажмите на
обратную стрелку расположенную сразу за текстом, чтобы вернуться на место
сноски в тексте. На мобильных устройствах это должно работать ещё лучше,
попробуйте сделать жест которым вы обычно говорите браузеру — <em>назад!</em>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Разбиение потока на отдельные сообщения или по другому -
<a href=https://blog.stephencleary.com/2009/04/message-framing.html target=_blank>message framing</a>
,
мы оставим за бортом. Предположим что одна операция чтения (вызов ReadFrom) возвращает одно сообщение,
которое в свою очередь содержит одно число и оно точно поместится в отведённый буфер.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Для некоторых конверсий реализация будет простой. Если конвертировать число
<code>int64</code> в <code>uint64</code> то для runtime не будет никакой работы. Компилятору достаточно
генерировать ассемблерные инструкции для работы со <em>знаковыми числами</em> до конвертации и
<em>инструкции для работы с беззнаковыми</em> числами после этой конвертации. Например, оператор
<code>>></code> должен генерировать инструкцию арифметического сдвига
<a href=https://www.felixcloutier.com/x86/sal:sar:shl:shr.html target=_blank>SAR — shift arithmetic right</a>
,
то есть с расширением знака, при работе
со знаковым числом. А при работе с беззнаковым, сдвиг должен быть логическим
<code>SHR — shift right</code>. Поэтому для сдвига переменной типа <code>int64</code> компилятор использует <code>SAR</code>.
После конверсии значения в <code>uint64</code> использует <code>SHR</code>. Содержимое памяти в процессе конверсии
не изменяется, поэтому рантайм языка Go в этой процедуре принимать участие не будет и
можно сказать что <em>этот процесс не имеет накладных расходов</em> во время работы программы.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Если вы, как и я из поколения IDE. А если нет, то и сами знаете как найти.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>То что мы видим в результате вызова команды <code>build -gcflags=-S</code> это промежуточное
представление называется Go-ассемблер. Мы не будем подробно останавливаться. Его знание
не играет роли для понимания статьи, <code>MOVL $1, AX</code> — это <em>копирование</em> значения <em>один</em> в
регистр <code>AX</code>, и этого достаточно. Если же вы хотите более подробно изучить его, начать
стоит с <a href=https://go.dev/doc/asm target=_blank>A Quick Guide to Go&rsquo;s Assembler</a>
.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>По первым отзывам на статью я понял что углубляться в ассемблер — плохо. Читаемость
падает. В результате я сильно сократил ассемблерные вставки и их объяснение. В этом случае
не нужно знать как именно строка становится аргументом. Но в сноске поговорим подробнее.
В Go недавно изменили способ передачи аргументов в функции. Как видите
сейчас на <code>amd64</code> они передаются через регистры (блоки памяти внутри микропроцессора),
. Первый аргумент (слева направо в сигнатуре функции) через регистр <code>AX</code>, второй через <code>BX</code>,
третий и четвёртый <code>CX</code> и <code>DI</code> соответственно. C возвращаемыми аргументами ситуация
аналогична.
<code>slicebytetostring</code> возвращает только один параметр типа string. Но строка в Go это
два поля — указатель на последовательность байт и значение длины строки. Поэтому, чтобы
передать <em>одну</em> строку, нужно ровно две ячейки памяти.
Итак, вызов функции приведёт к тому что в регистре <code>AX</code> будет указатель на последовательность
байт новой строки, а в регистре <code>BX</code> её длина. Функция <code>strconv.ParseUint</code> требует
ещё два аргумента, базу системы счисления и размер в числа в битах. Строка уже находится
в регистрах <code>AX/BX</code> (как удобно), а вот <code>CX</code> и <code>DI</code> нужно заполнить.
Это не полное описание процесса. Подробнее в статье
<a href=https://tip.golang.org/src/cmd/compile/abi-internal target=_blank>Calling Conversion</a>
.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>В версии 1.20 код немного изменён, но не принципиально. Мы не будем разбирать новую
версию, я уверен, после прочтения статьи вы без труда сами проанализируете изменение.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>Порядок байт. Тема не большая и не маленькая. И полностью не покрыть в сноске
и ссылку оставлять не хочется. Есть числа, которые занимают больше
чем 1 байт, а значит больше чем 1 ячейку в памяти. Например, <code>int16</code> это два
байта, то есть оно занимает две ячейки в памяти. Возьмём значение 1 типа int16 — <code>0x0001</code>. Старший байт
равен 0, младший — 1. У каждой ячейки есть адрес. Например, по адресу <code>0xffff00a7</code> будем хранить
байт <code>0x00</code>, а в следующем адресе <code>0xffff00a8</code> будем хранить <code>0x01</code>. Так, или наоборот?
Наоборот будет красивше, да, давайте в <code>0xffff00a7</code> хранить младший байт — <code>0x01</code>, а в
старшем адресе старший байт — <code>0x00</code>. Чтобы определить чётность или не чётность числа,
достаточно прочитать только один первый байт из памяти, удобно-ж, не правда-ли?
Если без шуток, разницы принципиальной нет. Продолжение чтения —
<a href=http://bear.ces.cwru.edu/eecs_314/endian_comparison.html target=_blank>Endian Comparision</a>
&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>Ссылки на слайс более не существует, но есть ссылка на заголовок строки. В заголовке
слайса есть ещё ёмкость. Вопрос на самостоятельное изучение, что станет с теми восемью байтами,
в которых хранилась емкость, после того как заголовок строки (если он находился в куче) будет
собран сборщиком мусора.&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>Текст. Текст или строки, обычно, чутка более сложные сущности чем просто
последовательности байт. Текст это закодированные символы, и, очевидно,
не всё множество последовательностей байт это валидный текст. Поэтому
некоторые языки, при преобразовании массива байт в строку могут производить
более сложные операции. Так же этот процесс не всегда успешен, например, если мы
не смогли распознать последовательность байт как символы в той или иной
кодировке. Язык Go поступает проще — строки могут содержать произвольный набор
байт. Поэтому вся эта мишура с валидацией ложится на плечи программистов, но
только если им это нужно. То есть те строки что есть в Go это не совсем те строки что вы можете
видеть, например, в Rust. Нет строк — нет проблем!&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p>На самом деле, это довольно распространённая ошибка. Чаще всего
её встретить можно при разыменование <code>nil</code> указателя, когда забыли
инициализировать поле структуры или что-то в этом роде.&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:12><p>Виды памяти в программе. Для нас
достаточно что для процесса (в котором исполняется наша программа) существует
неизменяемая область памяти и изменяемая. В неизменяемой памяти хранится, например,
сама программа, литералы строк. В изменяемой памяти хранятся переменные, стеки горутин,
любые значение выделенные в куче.
Это сложная тема. Детали сильно зависят от операционной системы. Я
не думаю что есть один материал описывающий всё досконально. Стартовая точка для
linux-based систем — <a href=https://manybutfinite.com/post/anatomy-of-a-program-in-memory target=_blank>Anatomy of a Program in Memory</a>
.
Более глубокое погружение —
<a href=https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4 target=_blank>Understanding the Memory Layout of Linux Executables</a>
.&#160;<a href=#fnref:12 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:13><p>Например, в протоколе TCP есть функциональность
<a href=https://en.wikipedia.org/wiki/TCP_window_scale_option target=_blank>окна</a>
приёма/передачи когда одна сторона уведомляет вторую о том, сколько
ещё байт она может принять.&#160;<a href=#fnref:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:14><p>Нельзя явно создавать экземпляры этих структур, только конвертировать из
строк/байт-слайс. Более подробно в комментарии к методу
<a href=https://pkg.go.dev/unsafe#Pointer target=_blank>unsafe.Pointer</a>
, пункт номер 6.&#160;<a href=#fnref:14 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:15><p>За вас это решение принимает компилятор. Так как Go является языком со сборщиком мусора
для программиста нет принципиальной разницы где хранить то или иное значение. Посмотрим на С,
вызывая функцию malloc вы явно просите runtime (да, даже у C он есть) выделить вам память в куче.
Такой подход может быть нужен для программ, жёстко контролирующих используемую память, встраиваемые
устройства — там памяти просто мало, ядра операционных систем — те гарантии, что ОС предоставляет
для пользовательских процессов по части памяти, она не может обеспечить для самой себя.
Но в Go вы не можете предполагать, где компилятор разместит значение.&#160;<a href=#fnref:15 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:16><p>Код конверсии не выдаёт ошибок на проверке go vet.&#160;<a href=#fnref:16 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><hr><div class=footer></div></div></main><div class=article-toc><div class=toc-wrapper><h4 id=contents></h4><nav id=TableOfContents><ul><li><a href=#чсть-1-поствведение>Чсть 1. Поствведение</a></li><li><a href=#чсть-2-что-такое-строки-и-что-такое-байты>Чсть 2. Что такое строки и что такое байты</a></li><li><a href=#чсть-3-а-как-же-строки>Чсть 3. А как же строки?</a></li><li><a href=#чсть-4-правильный-способ>Чсть 4. &ldquo;Правильный&rdquo; способ</a></li><li><a href=#заключение>Заключение</a></li></ul></nav></div></div></div></body></html>